name: Deploy helm chart to Kubernetes

on:
  push:
    branches:
      - master

env:
  CHART_NAME: 'ghost'
  CHART_REPO: 'https://geek-cookbook.github.io/helm-ghost'
  # CHART_REPO: 'https://charts.bitnami.com/bitnami'
  INGRESS_HOST: 'friends.funkypenguin.co.nz'

jobs:

  build:
    name: Deploy chart
    runs-on: ubuntu-latest
    steps:
            
    - name: 'Deploy chart'
      uses: 'deliverybot/helm@master'
      with:
        release: '${{env.CHART_NAME}}'
        namespace: '${{env.CHART_NAME}}'
        helm: 'helm3'
        chart: '${{env.CHART_NAME}}'
        repository: '${{env.CHART_REPO}}'

        # Insert values.yaml overrides here, indented as you would in a regular YAML file
        values: |
          ghostProtocol: https
          ghostPort: 443
          ghostHost: friends.funkypenguin.co.nz
          ghostUsername: ${{ secrets.GHOST_USERNAME }}
          ghostEmail: ${{ secrets.GHOST_EMAIL }}
          ghostPassword: ${{ secrets.GHOST_PASSWORD }}
          ghostBlogTitle: Funky Penguin
          smtpHost: ${{ secrets.GHOST_SMTP_HOST }}
          smtpPort: ${{ secrets.GHOST_SMTP_PORT }}
          smtpUser: ${{ secrets.GHOST_SMTP_USER }}
          smtpPassword: ${{ secrets.GHOST_SMTP_PASSWORD }}
          smtpService: mailgun
          smtpFromAddress: friends@funkypenguin.co.nz
          db:
            # Why not just let the chart give us a random password? 
            # Because the data is going to persist in a PVC, even if we delete the helm
            # release, and when we re-create the helm release, we might actually _want_ our data ;)
            password: ${{ secrets.GHOST_DB_PASSWORD }}
            rootUser:
              password: ${{ secrets.GHOST_DB_ROOT_PASSWORD }}
            persistence:
              size: 1Gi              
          service:
            type: ClusterIP # We'll access it via nginx-ingress-controller
          ingress:
            ## Set to true to enable ingress record generation
            enabled: true
            hosts:
              - name: '${{ env.INGRESS_HOST }}'
                path: /
                tls: true
                tlsSecret: letsencrypt-wildcard-cert
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: "letsencrypt-prod"
            persistence:
              size: 1Gi

      # Deployment will use the kubeconfig secret you created in the repo
      env:
        KUBECONFIG_FILE: '${{ secrets.KUBECONFIG }}'
        

